/* This object stores information, such as colors and other configurations for the simulator GUI */

let draw_config = {
    droplet: {
        borderColor: "#000000",
        borderWidth: 1
    },

    electrode: {
        backgroundColor: "#FFFFFF",
        borderColor: "#000000",
        borderWidth: 1,
        activeColor: "#FF0000"
    },

    group: {
        borderColor: "#000000",
        borderWidth: 1,
        selectedBorderColor: "#000000",
        selectedBorderWidth: 2
    },

    actuator: {
        backgroundColor: "#FF0000",
        backgroundOpacity: 100, // 0-255
        borderColor: "#FF0000",
        borderWidth: 1
    },

    sensor: {
        backgroundColor: "#1AA7EC",
        backgroundOpacity: 100, // 0-255
        borderColor: "#1AA7EC",
        borderWidth: 1
    },

    bubble: {
        backgroundColor: "none",
        backgroundOpacity: 0, // 0-255
        borderColor: "#000000",
        borderWidth: 1
    }
}


/* Gold electrode preset */
/*
let draw_config = {
    droplet: {
        borderColor: "#000000",
        borderWidth: 0
    },

    electrode: {
        backgroundColor: "#FFD700",
        borderColor: "#000000",
        borderWidth: 1,
        activeColor: "#FF0000"
    },

    group: {
        borderColor: "#000000",
        borderWidth: 0
    },

    actuator: {
        backgroundColor: "#FF0000",
        backgroundOpacity: 100, // 0-255
        borderColor: "#FF0000",
        borderWidth: 1
    },

    sensor: {
        backgroundColor: "#1AA7EC",
        backgroundOpacity: 100, // 0-255
        borderColor: "#1AA7EC",
        borderWidth: 1
    },

    bubble: {
        backgroundColor: "none",
        backgroundOpacity: 0, // 0-255
        borderColor: "#000000",
        borderWidth: 1
    }
}*/

/* Random preset Color */
/*
let draw_config = {
    droplet: {
        borderColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
        borderWidth: 0
    },

    electrode: {
        backgroundColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
        borderColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
        borderWidth: 1,
        activeColor: "#" + Math.floor(Math.random() * 16777215).toString(16)
    },

    group: {
        borderColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
        borderWidth: 0
    },

    actuator: {
        backgroundColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
        backgroundOpacity: 100, // 0-255
        borderColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
        borderWidth: 1
    },

    sensor: {
        backgroundColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
        backgroundOpacity: 100, // 0-255
        borderColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
        borderWidth: 1
    },

    bubble: {
        backgroundColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
        backgroundOpacity: 0, // 0-255
        borderColor: "#" + Math.floor(Math.random() * 16777215).toString(16),
        borderWidth: 1
    }
}
*/
/* BEGIN GUIBroker.js */

/*
 * gui_broker object 
 * This object is used to store data from the simulator. 
 * It basically acts as the broker between the GUI and simulation.
 */
let gui_broker = {
    sketch_ref: null,
    play_status: false,
    animate: false,
    simulator_time: 0,
    simulator_prev_time: 0,
    simulator_time_step: -1,
    data_to_download: [],
    board: {},
    droplets: [],
    electrodes: [],
    droplet_groups: {},
    prev_droplet_groups: {},

    /**
     * The function next_simulator_step calls on the simulator to run the next step
     * and send the corrosponding data.
     */
    next_simulator_step: () => {
        DotNet.invokeMethod('MicrofluidSimulator', 'JSSimulatorNextStep');
    },

    /**
     * The function next_simulator_step_time signals the simulator to take run
     * until a given time.
     */
    next_simulator_step_time: (time) => {
        DotNet.invokeMethod('MicrofluidSimulator', 'nextStepTime', time);
    },

    /**
     * The function update_simulator_container is used to send edited information
     * to the simulator.
     * @param {any} type
     * @param {any} JSONString
     */
    update_simulator_container: function (type, JSONString) {
        DotNet.invokeMethod('MicrofluidSimulator', 'updateSimulatorContainer', type, JSONString);
    },

    /**
     * The function goto_simulator_step is used to signal the simulator to go
     * to a given time.
     */
    goto_simulator_time_step: (time) => {
        DotNet.invokeMethod('MicrofluidSimulator', 'gotoSimulatorTimeStep', time);
    },

    /**
     * The function init_board is used to initialize the GUI board.
     */
    init_board: () => { console.log("BEFORE LOADED"); }, // Onload this will be defined in sketch.js

    /**
     * The function get_droplet_gorups will calculate the droplet groupings,
     * from the droplet data.
     */
    get_droplet_groups: function () {
        //this.droplet_groups = {};
        let droplet_groups_for_return = {};

        for (let i = 0; i < this.droplets.length; i++) {
            if (typeof droplet_groups_for_return[this.droplets[i].group] == "undefined") {
                droplet_groups_for_return[this.droplets[i].group] = [(this.droplets[i])];
            } else {
                droplet_groups_for_return[this.droplets[i].group].push(this.droplets[i]);
            }
        }
        return droplet_groups_for_return;
    }
};

/* END GUIBroker.js */
/* BEGIN GUIController.js */

/*
 * The gui_controller object is used to store information about the gui,
 * which are not a part of the actual sketch.
 */
let gui_controller = {
    //simulatorGUI: document.querySelector("#simulatorGUI"),
    //getLayerPanel: () => { return this.simulatorGUI.querySelector("#selectionPanel") },
    //getInputNodes: () => { return this.simulatorGUI.querySelector("#selectionPanel").getElementsByTagName('INPUT'); },
    //getInformaitonPanel: () => { return this.simulatorGUI.querySelector("#information"); },
    changeBoardName: (name) => { this.simulatorGUI.querySelector("#simulatorView span").innerHTML = name; },
    showGUI: () => { simulatorGUI.style.visibility = "visible"; },

    /**
     * Play status of changed by the play button
     */
    play_status: false,

    /**
     * Stores the data that is to be downloaded.
     */
    data_for_download: [],

    /**
     * The function download_data is used to download simulator data,
     * into JSON format.
     */
    download_data: function() {
        let jsonData = JSON.stringify(this.data_for_download);

        /* Download the data by forcing a click on an anchor element. */
        var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(jsonData);
        var dlAnchorElem = document.getElementById('downloadAnchorElem');
        dlAnchorElem.setAttribute("href", dataStr);
        dlAnchorElem.setAttribute("download", "data.json");
        dlAnchorElem.click();

        this.data_for_download = [];
    },


    /**
     * The function send_download_data is used by the simulator to send the data
     * to the GUI, which will then be formatted, so that it's ready for download.
     * @param {any} jsonData
     */
    store_download_data: function (jsonData) {
        let obj = JSON.parse(jsonData);
        obj.droplet_groups = gui_broker.get_droplet_groups();
        this.data_for_download.push(obj);
    }
}







/* END GUIController.js */
/* BEGIN LayerManager.js */

/*
 * The layer_manager object stores information about the different layers,
 * that are present in the sketch, these layers can be toggled off or on in
 * the selection panel.
 */
let selection_manager = {

    /*
     * The layers object stores information about each layer in the GUI.
     */
    layers: {
        real_time: {
            name: "real_time",
            value: "real_time",
            id: "real_time",
            text: "Real-Time Execution",    // Will be shown in layer panel list
            element: "insert",              // Reference - get toggled from here
            checkbox: "insert",
            checked: true
            //layer: "insert"               // Reference - pass to functions
        },
        draw_droplet_groups: {
            name: "droplet_group_draw_call",
            value: "droplet_group_draw_call",
            id: "draw_droplet_group",
            text: "Draw Droplet Groups", // Will be shown in layer panel list
            element: "insert",      // Reference - get toggled from here
            checkbox: "insert",
            checked: true
            //layer: "insert"         // Reference - pass to functions
        },
        draw_droplet_animations: {
            name: "draw_droplet_animations",
            value: "draw_droplet_animations",
            id: "draw_droplet_animations",
            text: "Animations", // Will be shown in layer panel list
            element: "insert",      // Reference - get toggled from here
            checkbox: "insert",
            checked: true
            //layer: "insert"         // Reference - pass to functions
        },
        draw_active_electrodes: {
            name: "draw_active_electrodes",
            value: "draw_active_electrodes",
            id: "draw_active_electrodes",
            text: "Draw Active Electrodes", // Will be shown in layer panel list
            element: "insert",      // Reference - get toggled from here
            checkbox: "insert",
            checked: true
            //layer: "insert"         // Reference - pass to functions
        },
        draw_actuators: {
            name: "draw_actuators",
            value: "draw_actuators",
            id: "draw_actuators",
            text: "Draw Actuators", // Will be shown in layer panel list
            element: "insert",      // Reference - get toggled from here
            checkbox: "insert",
            checked: true,
            layer: "insert"         // Reference - pass to functions
        },
        draw_sensors: {
            name: "draw_sensors",
            value: "draw_sensors",
            id: "draw_sensors",
            text: "Draw Sensors", // Will be shown in layer panel list
            element: "insert",      // Reference - get toggled from here
            checkbox: "insert",
            checked: true,
            layer: "insert"         // Reference - pass to functions
        },
        draw_bubbles: {
            name: "draw_bubbles",
            value: "draw_bubbles",
            id: "draw_bubbles",
            text: "Draw Bubbles", // Will be shown in layer panel list
            element: "insert",      // Reference - get toggled from here
            checkbox: "insert",
            checked: true
            //layer: "insert"         // Reference - pass to functions
        },
        draw_selected_element: {
            name: "draw_selected_element",
            value: "draw_selected_element",
            id: "draw_selected_element",
            text: "Draw Selected", // Will be shown in layer panel list
            element: "insert",      // Reference - get toggled from here
            checkbox: "insert",
            checked: true,
            layer: "insert"         // Reference - pass to functions
        },
        debug_electrode_text: {
            name: "debug_electrode_text",
            value: "debug_electrode_text",
            id: "db_e_text",
            text: "Electrode IDs", // Will be shown in layer panel list
            element: "insert",      // Reference - get toggled from here
            checkbox: "insert",
            checked: false,
            layer: "insert"         // Reference - pass to functions
        },
        draw_droplets: {
            name: "droplet_draw_call",
            value: "droplet_draw_call",
            id: "draw_droplet",
            text: "Draw Droplets", // Will be shown in layer panel list
            element: "insert",      // Reference - get toggled from here
            checkbox: "insert",
            checked: false
            //layer: "insert"         // Reference - pass to functions
        }

    },

    /**
     * The function initialize_layers will create toggles and layers
     * for each of the layers contained in the layers property.
     */
    initialize_layers: function () {

        for (let layer in this.layers) {
            var div = document.createElement('div');
            div.classList.add("form-check");
            div.innerHTML = `<input type='checkbox' name='${this.layers[layer].name}' value='${this.layers[layer].value}' id='${this.layers[layer].id}' class='form-check-input'/>
                             <label for='${this.layers[layer].name}' class='form-check-label'>${this.layers[layer].text}</label>`;
            this.layers[layer].element = div;
            this.layers[layer].checkbox = div.querySelector('input');
            this.layers[layer].checkbox.checked = this.layers[layer].checked;

            document.querySelector("#simulatorGUI").querySelector("#selectionPanel").querySelector('form').append(div);
        }
    },

    /**
     * The function draw_layers will draw the layers in the sketch.
     * @param {any} sketch
     */
    draw_layers: function (sketch) {
        for (let layer in this.layers) {
            if (this.layers[layer].hasOwnProperty("layer") && this.layers[layer].checkbox.checked) {
                // Draw
                sketch.image(this.layers[layer].layer, 0, 0);
            }
        }
    }
}

/* END LayerManager.js */
/* BEGIN InformationPanelManager.js */


/*
 * The information_panel_manager object is used to store both information
 * and logic, for which information about the sketch elements can be displayed.
 */
let information_panel_manager = {
    saveclose_button_div: null,
    edit_button: null,
    save_button: null,
    close_button: null,
    multiple_selection: null,
    double_clicked: false,
    selected_element: null,
    selected_element_type: null,
    information_element: null,
    editing: false,
    before_edit_values: {},

    /*
    * The object display_info stores the information that will be displayed
    * in the information panel, and which values can be edited.
    */
    display_info: {
        Droplet: {
            ID: "",
            substance_name: "",
            color: "",
            sizeX: 0,
            positionX: 0,
            positionY: 0,
            temperature: 0,
            volume: 0,
            group: 0
        },
        Droplet_editable: ["volume", "temperature", "color"],
        Electrode: {
            name: "",
            ID: "",
            status: 0,
            positionX: 0,
            positionY: 0,
            subscriptions: []
        },
        Electrode_editable: ["status"],
        Group: {
            groupID: 0,
            substance_name: "",
            color: "",
            temperature: 0,
            volume: 0,
            Type: ""
            //droplets: []
        },
        Group_editable: ["volume", "temperature", "color"],
        Actuator: {
            name: "",
            ID: 0,
            actuatorID: 0,
            type: "",
            valueActualTemperature: 0,
            valueDesiredTemperature: 0,
            valuePowerStatus: 0
        },
        Actuator_editable: [],
        Sensor: {
            name: "",
            ID: 0,
            sensorID: 0,
            type: "",
            valueRed: 0,
            valueBlue: 0,
            valueGreen: 0,
            valueTemperature: 0
        },
        Sensor_editable: []
    },

    /**
     * The function information_filer will take the type of element, the element
     * and filter it, such that only the information we choose is displayed.
     *
     * There are two other arguments, namely the element, and groupID for group type. 
     * @param {any} type
     */
    information_filter: function (type) {
        let returnVal;
        this.selected_element_type = type;

        switch (type) {
            case ("Droplet"):
                let droplet = arguments[1];

                returnVal = this.display_info[type];

                for (let key in returnVal) {
                    returnVal[key] = droplet[key];
                }

                returnVal.Type = type;
                return returnVal;

                break;
            case ("Electrode"):
                let electrode = arguments[1];

                returnVal = this.display_info[type];

                for (let key in returnVal) {
                    returnVal[key] = electrode[key];
                }

                returnVal.Type = type;
                return returnVal;

                break;
            case ("Group"):

                let id = arguments[2];
                let group = arguments[1];

                returnVal = { ...this.display_info[type] };
                returnVal.droplets = [];
                returnVal.groupID = id;

                returnVal.substance_name = group[0].substance_name;
                returnVal.color = group[0].color;

                for (let i = 0; i < group.length; i++) {
                    let droplet = group[i];
                    returnVal.droplets.push(droplet.ID);
                    for (let key in droplet) {
                        if (key == "volume") { returnVal.volume += droplet[key] }
                        if (key == "temperature") { returnVal.temperature += droplet[key] }
                    }
                }

                returnVal.temperature = returnVal.temperature / group.length;

                returnVal.Type = type;
                return returnVal;
                break;

            case ("Actuator"):
                let actuator = arguments[1];

                returnVal = this.display_info[type];

                for (let key in returnVal) {
                    returnVal[key] = actuator[key];
                }

                returnVal.Type = type;
                return returnVal;

                break;

            case ("Sensor"):
                let sensor = arguments[1];

                returnVal = this.display_info[type];

                for (let key in returnVal) {
                    returnVal[key] = sensor[key];
                }

                returnVal.Type = type;
                return returnVal;

                break;
        }
    },

    /**
     * This function controls the condition, where the user can select multiple
     * elements with a double click, this can happen if more than one element
     * is stacked in the sketch.
     * @param {any} layer
     */
    draw_multiple_selection: function (layer) {

        let s_list = [];
        for (let i = 0; i < Object.keys(information_panel_manager.multiple_selection).length; i++) {
            s_list.push((i + 1) + " " + Object.keys(information_panel_manager.multiple_selection)[i]);
        }

        layer.textSize(14);
        layer.fill("#1b6ec2");
        let max_width = Math.max.apply(Math, s_list.map(function (o) { return layer.textWidth(o); }))
        let max_height = layer.textAscent(s_list[0]) * s_list.length + 10 + 5 * s_list.length;

        layer.stroke("#000000");
        layer.rect(layer.mouseX, layer.mouseY, max_width + 20, max_height, 5);

        layer.noStroke();
        layer.fill("#ffffff");
        for (let i in s_list) {
            layer.text(s_list[i], layer.mouseX + 10, layer.mouseY + (layer.textAscent(s_list[i]) * (parseInt(i) + 1)) + 5 * (parseInt(i) + 1));
        }
        layer.stroke("#000000");
    },
    /**
     * Draws the selected element
     * @param {any} layer
     * @param {any} element
     */
    draw_selected_element: function(layer, element) {
        layer.clear();
        if (element == null) { return; }

        if (typeof element.status != "undefined") {

            // Electrode
            for (let i = 0; i < gui_broker.electrodes.length; i++) {
                let electrode = gui_broker.electrodes[i];

                if (electrode.ID != element.ID) { continue; }

                layer.noFill();
                layer.stroke("blue");
                layer.strokeWeight(3);

                // Check the electrode shape
                if (electrode.shape == 1) {
                    layer.beginShape();
                    for (let i = 0; i < electrode.corners.length; i++) {
                        layer.vertex(electrode.positionX + electrode.corners[i][0] + 0.5, electrode.positionY + electrode.corners[i][1] + 0.5);
                    }
                    layer.endShape(layer.CLOSE);
                } else {
                    layer.rect(electrode.positionX, electrode.positionY, electrode.sizeX, electrode.sizeY);
                }
            }
        } else {

        }
    },

    /**
     * This function will take an element and display the correct information
     * in the information panel.
     * @param {any} element
     */
    draw_information: function (element) {

        this.onCancel();

        let informationPanel = document.querySelector("#simulatorGUI").querySelector("#information");
        let informationView = informationPanel.querySelector("#informationElements");
        informationView.innerHTML = "";

        let div = document.createElement("div");

        for (let key in element) {
            if (!(key in this.display_info[element.Type])) { continue; }

            let innerDiv = document.createElement("div");
            let innerInput = document.createElement("input");

            innerDiv.innerHTML = key + ": ";
            innerDiv.classList.add("information_item");
            innerInput.value = element[key];
            innerInput.readOnly = true;
            innerInput.classList.add("input_readonly");

            innerDiv.append(innerInput);
            div.append(innerDiv);
        }

        informationView.append(div);
    },

    /**
     * This function controls the logic of editing values of an element.
     */
    onEdit: function () {

        if (this.selected_element == null) { return; }

        this.before_edit_values = {};

        this.edit_button.style.visibility = "hidden";
        this.saveclose_button_div.style.visibility = "visible";
        this.editing = true;

        let element = this.information_element;

        let type = element.Type;
        let editable_values = this.display_info[type + "_editable"];

        let divs = document.querySelector("#informationElements").getElementsByClassName("information_item");
        let inputs = document.querySelector("#informationElements").getElementsByTagName("input");

        var div_arr = Array.prototype.slice.call(divs);
        var input_arr = Array.prototype.slice.call(inputs);

        for (let i in input_arr) {
            let attribute = div_arr[i].textContent.slice(0, div_arr[i].textContent.length - 2);
            let input = input_arr[i];

            if (editable_values.includes(attribute)) {
                this.before_edit_values[attribute] = input.value;
                input.readOnly = false;
                input.classList.remove("input_readonly");
            }
        }
    },

    /**
     * This function controls the logic of canceling an edit on an element.
     */
    onCancel: function () {
        this.edit_button.style.visibility = "visible";
        this.saveclose_button_div.style.visibility = "hidden";

        this.editing = false;

        let element = this.information_element;

        let type = element.Type;
        let editable_values = this.display_info[type + "_editable"];

        let divs = document.querySelector("#informationElements").getElementsByClassName("information_item");
        let inputs = document.querySelector("#informationElements").getElementsByTagName("input");

        var div_arr = Array.prototype.slice.call(divs);
        var input_arr = Array.prototype.slice.call(inputs);

        for (let i in input_arr) {
            let attribute = div_arr[i].textContent.slice(0, div_arr[i].textContent.length - 2);
            let input = input_arr[i];

            if (editable_values.includes(attribute)) {
                input.value = this.before_edit_values[attribute];
                input.readOnly = true;
                input.classList.add("input_readonly");
            }
        }
    },

    /**
     * The function onSave controls the logic for saving the edit of element values,
     * and will call upon the gui_broker to send the information to the simulator.
     */
    onSave: function () {
        
        this.edit_button.style.visibility = "visible";
        this.saveclose_button_div.style.visibility = "hidden";

        this.editing = false;

        let element = this.information_element;

        let type = element.Type;
        let editable_values = this.display_info[type + "_editable"];

        let divs = document.querySelector("#informationElements").getElementsByClassName("information_item");
        let inputs = document.querySelector("#informationElements").getElementsByTagName("input");

        let div_arr = Array.prototype.slice.call(divs);
        let input_arr = Array.prototype.slice.call(inputs);

        let values_to_send = {};

        for (let i in input_arr) {
            let attribute = div_arr[i].textContent.slice(0, div_arr[i].textContent.length - 2);
            let input = input_arr[i];

            if (editable_values.includes(attribute)) {
                input.readOnly = true;
                input.classList.add("input_readonly");

                // TODO: Check if the input value is ok!
                values_to_send[attribute] = input.value;
            }
        }

        if (this.selected_element_type == "Group") {
            values_to_send.droplets = this.selected_element.droplets;
            values_to_send.groupID = this.selected_element.groupID;
        } else {
            values_to_send.ID = this.selected_element.ID;
        }

        // Send the new element values to the simulator
        gui_broker.update_simulator_container(this.selected_element_type, JSON.stringify(values_to_send));
    },

    /**
     * The clear function will clear the information panel from any selected element.
     */
    clear: function () {
        this.editing = false;
        this.edit_button.style.visibility = "visible";
        this.saveclose_button_div.style.visibility = "hidden";

        this.selected_element = null;
        this.information_element = null;
        this.selected_element_type = null;

        let div = document.querySelector("#informationElements");
        div.innerHTML = "";
    },

    /**
     * The dynamic_update function allows of the selection of elements,
     * even when the simulation is running and the elements of the GUI are updating.
     * This allows realtime viewing of the attributes changing.
     */
    dynamic_update: function () {

        if (this.selected_element == null) { return; }

        let cur_element = this.selected_element;
        let new_element = null;
        let type = this.selected_element_type.toLowerCase();
        let groupID = (typeof cur_element.groupID === 'undefined') ? null : cur_element.groupID;

        if (type == "group") {
            let group_list = gui_broker.droplet_groups;
            new_element = group_list[groupID];

        } else {

            let element_list = gui_broker.board[type + "s"];
            element_list.forEach((element) => {
                if (element.ID == cur_element.ID) {
                    new_element = element;
                }
            })
        }

        // If the element is deleted clear the panel
        if (new_element == null) { this.clear(); return; }

        // Update information
        this.selected_element = this.information_filter(this.selected_element_type, new_element, groupID);
        this.information_element = this.information_filter(this.selected_element_type, new_element, groupID);
        this.draw_information(this.information_filter(this.selected_element_type, new_element, groupID));
    }

}

/* END InformationPanelManager.js */

/* 
 * Written by Joel A. V. Madsen
 * This file contains the main graphical user interface components,
 * it uses p5js as the framework, for which we can initialize a canvas
 * and draw onto it.
 */


/* 
 * Declaration of script "global" variables.
 * These variables are used by both the global functions but also by the p5js script.
 */
let simulator_droplets = []; // Not used
let simulator_electrodes = []; // Not used
let lerp_amount = 0;     // Used to interpolate between droplet positions.


// Layer for electrodes, since their placement are static
let layer_electrode;


/*
 * P5JS Sketch
 * The sketch function uses the p5js framework to create GUI elements within a Canvas
 */
let sketch = function (p) {

    /*
     * Setup is called once on start of the sketch.
     */
    p.setup = function () {
        // Create main canvas
        let canvas = p.createCanvas(1, 1);
        canvas.mouseClicked(onMouseClicked);
        canvas.doubleClicked(onMouseDoubleClicked);
        
        console.log(canvas.position());

        // Used to get sharper edges in sketch
        p.pixelDensity(4);

        // Create layers
        //layer_electrode_id = p.createGraphics(1, 1);
        layer_electrode = p.createGraphics(1, 1);
        console.log("setup");

        //p.frameRate(10);

        let saveclose_button_div = p.select("#saveclose_button_div");
        information_panel_manager.saveclose_button_div = saveclose_button_div.elt;

        let edit_button = p.select("#edit_button");
        information_panel_manager.edit_button = edit_button.elt;
        edit_button.mousePressed(() => {
            information_panel_manager.onEdit();
        });
        //edit_button.style("visibility", "visible");

        let cancel_button = p.select("#cancel_button");
        cancel_button.mousePressed(() => {
            information_panel_manager.onCancel();
        });

        let save_button = p.select("#save_button");
        save_button.mousePressed(() => {
            information_panel_manager.onSave();
        });
    }


    /*
     * Draw is called every frame of the sketch.
     */
    
    p.draw = function () {
        //console.time("DrawTime");
        if ((gui_broker.play_status && selection_manager.layers.draw_droplet_animations.checkbox.checked) || gui_broker.animate) {
            lerp_amount += 0.07; // Maybe make an animation object, or global variables
        }

        /* Redraw the canvas */
        p.background(240);

        /* Draw calls */
        p.image(layer_electrode, 0, 0);

        if (selection_manager.layers.draw_active_electrodes.checkbox.checked) { draw_active_electrodes(); }

        // Draw all direct layers
        selection_manager.draw_layers(p);

        // Draw selected electrodes
        if (selection_manager.layers.draw_selected_element.checkbox.checked) { information_panel_manager.draw_selected_element(selection_manager.layers.draw_selected_element.layer, information_panel_manager.selected_element); }

        // Draw droplet groups
        if (selection_manager.layers.draw_droplet_groups.checkbox.checked || selection_manager.layers.draw_droplet_animations.checkbox.checked) { draw_droplet_groups(); }

        // Draw and control animations
        if (selection_manager.layers.draw_droplet_animations.checkbox.checked) {

            let on_time_lerp = ((Date.now() - gui_broker.simulator_time) / 1000) / (gui_broker.board.currentTime - gui_broker.simulator_prev_time);
            let on_count_lerp = p.constrain(lerp_amount, 0, 1);

            let c_lerp_amount = p.constrain(p.max(on_time_lerp, on_count_lerp), 0, 1);

            // For same groups
            for (i in gui_broker.droplet_groups) {
                lerpGroupVertices(i, c_lerp_amount);
            }

            // For group splits
            for (groupID in gui_broker.droplet_groups) {
                let new_groups = findGroupSplit(groupID);
                for (i in new_groups) {
                    lerpGroupVertices(new_groups[i], c_lerp_amount, groupID);
                }
            }

            
        }

        // Draw bubbles
        if (selection_manager.layers.draw_bubbles.checkbox.checked) { draw_bubbles(); }

        // Draw multiple selection
        if (information_panel_manager.double_clicked) { information_panel_manager.draw_multiple_selection(p); }

        // Control non real-time execution
        if (gui_broker.play_status && lerp_amount >= 1.3 && !selection_manager.layers.real_time.checkbox.checked && selection_manager.layers.draw_droplet_animations.checkbox.checked) {
            gui_broker.next_simulator_step();
            lerp_amount = 0;
            gui_broker.animate = false;

        } else if (gui_broker.play_status && !selection_manager.layers.draw_droplet_animations.checkbox.checked && !selection_manager.layers.real_time.checkbox.checked) {
            gui_broker.next_simulator_step();

        } else if (gui_broker.animate && lerp_amount >= 1) {
            gui_broker.animate = false;

        }


        if (selection_manager.layers.draw_droplets.checkbox.checked) { draw_droplet(); }


        // Control real-time execution
        if (gui_broker.play_status && (((Date.now() - gui_broker.simulator_time) / 1000) + gui_broker.simulator_prev_time) >= gui_broker.board.currentTime) {
            console.log("Ellapsed time: " + ((Date.now() - gui_broker.simulator_time) / 1000) + " seconds", "Actual time: " + (((Date.now() - gui_broker.simulator_time) / 1000) + gui_broker.simulator_prev_time),"Previous time: " + gui_broker.simulator_prev_time,"Current time: " + gui_broker.board.currentTime);
            lerp_amount = 1;
            gui_broker.next_simulator_step_time(gui_broker.simulator_time_step);
        }

    }


    function findGroupSplit(groupID) {

        let cur_group = gui_broker.droplet_groups[groupID];
        let prev_group = gui_broker.prev_droplet_groups[groupID];
        if (typeof cur_group == "undefined" || typeof prev_group == "undefined") { return; }

        if (!(Object.keys(gui_broker.prev_droplet_groups).length < Object.keys(gui_broker.droplet_groups).length)) { return; }

        let possible_split_droplets = [];
        for (i in prev_group) {
            for (j in cur_group) {

                if (prev_group[i].ID != cur_group[j].ID) {
                    possible_split_droplets.push(prev_group[i].ID);
                }
            }
        }

        let new_groups = [];
        for (i in possible_split_droplets) {
            for (j in gui_broker.droplets) {
                if (possible_split_droplets[i] == gui_broker.droplets[j].ID && gui_broker.droplets[j].group != groupID) {
                    if (!new_groups.includes(gui_broker.droplets[j].group)) { new_groups.push(gui_broker.droplets[j].group); }
                }
            }
        }

        return new_groups;
    }


    function lerpGroupVertices(groupID, amount, prevGroupID) { // prevGroupID is optional


        let cur_group = gui_broker.droplet_groups[groupID];

        if (typeof prevGroupID == "undefined") { prevGroupID = groupID }

        let prev_group = gui_broker.prev_droplet_groups[prevGroupID];

        if (typeof cur_group == "undefined") { return; }

        if (typeof prev_group != "undefined") {
            let vertex_pairs_before = getGroupVertexPairsForLerp(groupID, prevGroupID);
            let vertex_pairs = getGroupVertexPairsForLerp(groupID, prevGroupID);

            let vertX;
            let vertY;
            //[[[x1, x2], [y1, y2]] ... ]

            for (i in vertex_pairs) {
                vertX = p.lerp(vertex_pairs[i][0][0], vertex_pairs[i][0][1], amount);
                vertY = p.lerp(vertex_pairs[i][1][0], vertex_pairs[i][1][1], amount);


                vertex_pairs[i][0][0] = vertX;
                vertex_pairs[i][1][0] = vertY;

                for (a in cur_group.vertices) {
                    let vert = cur_group.vertices[a];
                    for (b in vertex_pairs_before) {

                        if (vert[0] == vertex_pairs_before[b][0][1] && vert[1] == vertex_pairs_before[b][1][1] && vertex_pairs_before[b][0][1] == vertex_pairs[i][0][1] && vertex_pairs_before[b][1][1] == vertex_pairs[i][1][1]) {
                            gui_broker.droplet_groups[groupID].vertices[a] = [vertX, vertY];
                        }
                    }
                }
            }


        }

        if (typeof gui_broker.droplet_groups[groupID] == "undefined") { return; }

        let points_vector = [];
        for (let j = 0; j < gui_broker.droplet_groups[groupID].vertices.length; j++) {
            points_vector.push(p.createVector(p.round(gui_broker.droplet_groups[groupID].vertices[j][0], 2), p.round(gui_broker.droplet_groups[groupID].vertices[j][1], 2)));
        }

        p.fill(gui_broker.droplet_groups[groupID][0].color);
        draw_rounded(p, points_vector, 50);

        /*p.fill("black");
        for (let j = 0; j < gui_broker.droplet_groups[groupID].vertices.length; j++) {
            p.ellipse(gui_broker.droplet_groups[groupID].vertices[j][0], gui_broker.droplet_groups[groupID].vertices[j][1], 3, 3);
        }*/
    }

    function getGroupVertexPairsForLerp(groupID, prevGroupID) {
        let cur_group = gui_broker.droplet_groups[groupID];

        if (typeof prevGroupID == "undefined") { prevGroupID = groupID }
        let prev_group = gui_broker.prev_droplet_groups[prevGroupID];

        if (typeof cur_group == "undefined" || typeof prev_group == "undefined") { return; }

        let vertices_to_lerp = getGroupVerticesToLerp(groupID, prevGroupID);

        let vertex_pairs = [];
        // [[[x1,x2],[y1,y2]] ... ]

        // Find closes point in current group
        for (i in vertices_to_lerp) {
            let min_dist = [9999, "point"]; // min_dist, point
            for (j in cur_group.vertices) {
                let dist = p.dist(vertices_to_lerp[i][0], vertices_to_lerp[i][1], cur_group.vertices[j][0], cur_group.vertices[j][1]);
                if (dist < min_dist[0]) {
                    min_dist = [dist, cur_group.vertices[j]];
                }
            }
            vertex_pairs.push([[vertices_to_lerp[i][0], min_dist[1][0]], [vertices_to_lerp[i][1], min_dist[1][1]]]);
            vertices_to_lerp.push([min_dist[1][0], min_dist[1][1]]);
        }

        return vertex_pairs;

    }

    function getGroupVerticesToLerp(groupID, prevGroupID) {
        let cur_group = gui_broker.droplet_groups[groupID];

        if (typeof prevGroupID == "undefined") { prevGroupID = groupID }
        let prev_group = gui_broker.prev_droplet_groups[prevGroupID];

        if (typeof cur_group == "undefined" || typeof prev_group == "undefined") { return; }

        if (typeof prev_group.vertices == "undefined") { return; }
        let difference = prev_group.vertices.filter(x => !cur_group.vertices.includes(x));

        return difference;
    }

    function getGroupVerticesToLerp2(groupID, prevGroupID) {
        let cur_group = gui_broker.droplet_groups[groupID];

        if (typeof prevGroupID == "undefined") { prevGroupID = groupID }
        let prev_group = gui_broker.prev_droplet_groups[prevGroupID];

        if (typeof cur_group == "undefined" || typeof prev_group == "undefined") { return; }

        // Find vertices to lerp
        let newArray = [];

        for (i in prev_group.vertices) {
            let min_dist = 9999;
            for (j in cur_group.vertices) {
                let dist = p.dist(prev_group.vertices[i][0], prev_group.vertices[i][1], cur_group.vertices[j][0], cur_group.vertices[j][1]);
                min_dist = p.min(min_dist, dist);
            }

            if (min_dist > cur_group[0].sizeX / 2) {
                newArray.push([prev_group.vertices[i][0], prev_group.vertices[i][1]]);
            }
        }

        return newArray;
    }



    /* Handle key presses */
    p.keyPressed = function () {

        // Escape will clear the information panel, enter will save it
        if (information_panel_manager.selected_element != null && p.keyCode == 27) {
            information_panel_manager.clear();
        } else if (information_panel_manager.selected_element != null && information_panel_manager.editing && p.keyCode == 13) {
            information_panel_manager.onSave();
        }


        
        if (information_panel_manager.double_clicked) {
            if (p.key <= Object.keys(information_panel_manager.multiple_selection).length) {
                console.log("inside");
                //information_panel_manager.selected_element = information_panel_manager.multiple_selection[Object.keys(information_panel_manager.multiple_selection)[p.key - 1]];
                console.log(Object.keys(information_panel_manager.multiple_selection)[p.key - 1], information_panel_manager.multiple_selection[Object.keys(information_panel_manager.multiple_selection)[p.key - 1]]);

                let type = Object.keys(information_panel_manager.multiple_selection)[p.key - 1];
                let element = information_panel_manager.multiple_selection[Object.keys(information_panel_manager.multiple_selection)[p.key - 1]];
                let groupID = (typeof element[0] === 'undefined') ? null : element[0].group;

                information_panel_manager.selected_element = information_panel_manager.information_filter(type, element, groupID);
                information_panel_manager.information_element = information_panel_manager.information_filter(type, element, groupID);
                information_panel_manager.draw_information(information_panel_manager.information_filter(type, element, groupID));

                information_panel_manager.double_clicked = false;
                information_panel_manager.multiple_selection = null;
            }
        }
    }

    /** Handle single mouse clicks */
    function onMouseClicked() {
        information_panel_manager.double_clicked = false;
        information_panel_manager.multiple_selection = null;

        // Handle click on droplet group
        if (selection_manager.layers.draw_droplet_groups.checkbox.checked) {
            for (let i in gui_broker.droplet_groups) {
                if (polygon_contains(gui_broker.droplet_groups[i].vertices, p.mouseX, p.mouseY)) {
                    information_panel_manager.selected_element = information_panel_manager.information_filter("Group", gui_broker.droplet_groups[i], i);
                    information_panel_manager.information_element = information_panel_manager.information_filter("Group", gui_broker.droplet_groups[i], i);
                    information_panel_manager.draw_information(information_panel_manager.information_filter("Group", gui_broker.droplet_groups[i], i));
                    return;
                }
            }
        }

        // Handle click on droplet
        if (selection_manager.layers.draw_droplets.checkbox.checked) {
            for (let i in gui_broker.droplets) {
                let droplet = gui_broker.droplets[i];

                // Check mouse over droplet
                if (p.dist(p.mouseX, p.mouseY, droplet.positionX, droplet.positionY) < droplet.sizeX / 2) {
                    information_panel_manager.selected_element = droplet;
                    information_panel_manager.information_element = information_panel_manager.information_filter("Droplet", droplet);
                    information_panel_manager.draw_information(information_panel_manager.information_filter("Droplet", droplet));
                    return;
                }
            }
        }

        // Handle click on sensor
        if (selection_manager.layers.draw_sensors.checkbox.checked) {
            for (let i in gui_broker.board.sensors) {
                let sensor = gui_broker.board.sensors[i];
                let vertexes = [[sensor.positionX, sensor.positionY], [sensor.positionX + sensor.sizeX, sensor.positionY], [sensor.positionX + sensor.sizeX, sensor.positionY + sensor.sizeY], [sensor.positionX, sensor.positionY + sensor.sizeY]];

                if (polygon_contains(vertexes, p.mouseX, p.mouseY)) {
                    information_panel_manager.selected_element = sensor;
                    information_panel_manager.information_element = information_panel_manager.information_filter("Sensor", sensor);
                    information_panel_manager.draw_information(information_panel_manager.information_filter("Sensor", sensor));
                    return;
                }
            }
        }

        // Handle click on actuator
        if (selection_manager.layers.draw_actuators.checkbox.checked) {
            for (let i in gui_broker.board.actuators) {
                let actuator = gui_broker.board.actuators[i];
                let vertexes = [[actuator.positionX, actuator.positionY], [actuator.positionX + actuator.sizeX, actuator.positionY], [actuator.positionX + actuator.sizeX, actuator.positionY + actuator.sizeY], [actuator.positionX, actuator.positionY + actuator.sizeY]];

                if (polygon_contains(vertexes, p.mouseX, p.mouseY)) {
                    information_panel_manager.selected_element = actuator;
                    information_panel_manager.information_element = information_panel_manager.information_filter("Actuator", actuator);
                    information_panel_manager.draw_information(information_panel_manager.information_filter("Actuator", actuator));
                    return;
                }
            }
        }

        // Handle click on electrode
        for (let i in gui_broker.electrodes) {
            let electrode = gui_broker.electrodes[i];
            if (electrodeContains(electrode, p.mouseX, p.mouseY)) {
                information_panel_manager.selected_element = electrode;
                information_panel_manager.information_element = information_panel_manager.information_filter("Electrode", electrode);
                information_panel_manager.draw_information(information_panel_manager.information_filter("Electrode", electrode));
                return;
            }
        }
    }

    function onMouseDoubleClicked() {


        let list_of_elements = {};
        // Handle click on droplet group
        if (selection_manager.layers.draw_droplet_groups.checkbox.checked) {
            for (let i in gui_broker.droplet_groups) {
                if (polygon_contains(gui_broker.droplet_groups[i].vertices, p.mouseX, p.mouseY)) {
                    list_of_elements["Group"] = gui_broker.droplet_groups[i];
                }
            }
        }

        // Handle click on droplet
        if (selection_manager.layers.draw_droplets.checkbox.checked) {
            for (let i in gui_broker.droplets) {
                let droplet = gui_broker.droplets[i];

                // Check mouse over droplet
                if (p.dist(p.mouseX, p.mouseY, droplet.positionX, droplet.positionY) < droplet.sizeX / 2) {
                    list_of_elements["Droplet"] = (droplet);
                }
            }
        }

        // Handle click on sensor
        if (selection_manager.layers.draw_sensors.checkbox.checked) {
            for (let i in gui_broker.board.sensors) {
                let sensor = gui_broker.board.sensors[i];
                let vertexes = [[sensor.positionX, sensor.positionY], [sensor.positionX + sensor.sizeX, sensor.positionY], [sensor.positionX + sensor.sizeX, sensor.positionY + sensor.sizeY], [sensor.positionX, sensor.positionY + sensor.sizeY]];

                if (polygon_contains(vertexes, p.mouseX, p.mouseY)) {
                    list_of_elements["Sensor"] = sensor;
                }
            }
        }

        // Handle click on actuator
        if (selection_manager.layers.draw_actuators.checkbox.checked) {
            for (let i in gui_broker.board.actuators) {
                let actuator = gui_broker.board.actuators[i];
                let vertexes = [[actuator.positionX, actuator.positionY], [actuator.positionX + actuator.sizeX, actuator.positionY], [actuator.positionX + actuator.sizeX, actuator.positionY + actuator.sizeY], [actuator.positionX, actuator.positionY + actuator.sizeY]];

                if (polygon_contains(vertexes, p.mouseX, p.mouseY)) {
                    list_of_elements["Actuator"] = actuator;
                }
            }
        }

        // Handle click on electrode
        for (let i in gui_broker.electrodes) {
            let electrode = gui_broker.electrodes[i];
            if (electrodeContains(electrode, p.mouseX, p.mouseY)) {
                list_of_elements["Electrode"] = (electrode);
            }
        }
        console.log("double clicked", list_of_elements);

        if (Object.keys(list_of_elements).length > 1) {
            information_panel_manager.selected_element = null;
            information_panel_manager.clear();

            information_panel_manager.double_clicked = true;
            information_panel_manager.multiple_selection = list_of_elements;
        }
    }

    /**
     * Checks whether a point (x, y) is contained within an electrode.
     * @param {any} electrode
     * @param {any} x
     * @param {any} y
     */
    function electrodeContains(electrode, x, y) {
        let vertexes = [];
        if (electrode.shape == 0) {
            vertexes = [[0, 0], [electrode.sizeX, 0], [electrode.sizeX, electrode.sizeY], [0, electrode.sizeY]];
        } else {
            vertexes = electrode.corners;
        }

        let i;
        let j;
        let result = false;
        for (i = 0, j = vertexes.length - 1; i < vertexes.length; j = i++) {
            let ivertX = vertexes[i][0] + electrode.positionX;
            let ivertY = vertexes[i][1] + electrode.positionY;
            let jvertX = vertexes[j][0] + electrode.positionX;
            let jvertY = vertexes[j][1] + electrode.positionY;

            if ((ivertY > y) != (jvertY > y) && (x < (jvertX - ivertX)
                * (y - ivertY) / (jvertY - ivertY) + ivertX)) {
                result = !result;
            }
        }

        return result;
    }

    function polygon_contains(vertexes, x, y) {
        let i;
        let j;
        let result = false;
        for (i = 0, j = vertexes.length - 1; i < vertexes.length; j = i++) {
            let ivertX = vertexes[i][0];
            let ivertY = vertexes[i][1];
            let jvertX = vertexes[j][0];
            let jvertY = vertexes[j][1];

            if ((ivertY > y) != (jvertY > y) && (x < (jvertX - ivertX)
                * (y - ivertY) / (jvertY - ivertY) + ivertX)) {
                result = !result;
            }
        }
        return result;
    }


    function draw_droplet_groups() {
        // TESTING GROUPED DROPLETS
        for (let i in gui_broker.droplet_groups) {
            let check_size = gui_broker.electrodes[0].sizeX / 2;
            let current_droplet = gui_broker.droplet_groups[i][0];
            let current_droplet_point = [current_droplet.positionX - check_size, current_droplet.positionY - check_size];
            let concave_point = null;

            //let draw_size = current_droplet.sizeX / 2;
            let droplet_draw_point = [current_droplet.positionX - current_droplet.sizeX / 2, current_droplet.positionY - current_droplet.sizeX / 2];

            // Change so case where theres no path from current point is valid
            let points_to_draw = [];

            while (JSON.stringify(points_to_draw).indexOf(JSON.stringify(droplet_draw_point)) == -1) {
                //for (let ab = 0; ab < 4; ab++) {
                let top_left = null
                let top_right = null;
                let bottom_left = null;
                let bottom_right = null;

                for (let j in gui_broker.droplet_groups[i]) {
                    let other_droplet = gui_broker.droplet_groups[i][j];

                    // Check cases
                    if (other_droplet.positionX == current_droplet_point[0] + check_size && other_droplet.positionY == current_droplet_point[1] - check_size) {
                        top_right = other_droplet;
                    } else if (other_droplet.positionX == current_droplet_point[0] - check_size && other_droplet.positionY == current_droplet_point[1] + check_size) {
                        bottom_left = other_droplet;
                    } else if (other_droplet.positionX == current_droplet_point[0] - check_size && other_droplet.positionY == current_droplet_point[1] - check_size) {
                        top_left = other_droplet;
                    } else if (other_droplet.positionX == current_droplet_point[0] + check_size && other_droplet.positionY == current_droplet_point[1] + check_size) {
                        bottom_right = other_droplet;
                    }
                }

                if (top_right == null && bottom_right != null) {

                    // Concave corner case
                    if (top_left != null && bottom_left != null) {
                        concave_point = [top_left.positionX + top_left.sizeY / 2, bottom_right.positionY - bottom_right.sizeY / 2];

                        if (JSON.stringify(points_to_draw).indexOf(
                            JSON.stringify(concave_point)) == -1) {
                            points_to_draw.push(concave_point);
                        }
                    }

                    // Convex corner case
                    if (bottom_left == null) {
                        points_to_draw.push(droplet_draw_point);
                    }

                    if (JSON.stringify(points_to_draw).indexOf(
                        JSON.stringify([bottom_right.positionX - bottom_right.sizeX / 2,
                        bottom_right.positionY - bottom_right.sizeY / 2])) == -1 && bottom_left == null) {
                        points_to_draw.push([bottom_right.positionX - bottom_right.sizeX / 2, bottom_right.positionY - bottom_right.sizeY / 2]);
                    }

                    droplet_draw_point = [bottom_right.positionX + bottom_right.sizeX / 2, bottom_right.positionY - bottom_right.sizeY / 2];
                    current_droplet_point = [current_droplet_point[0] + check_size * 2, current_droplet_point[1]];

                } else if (bottom_right == null && bottom_left != null) {

                    // Concave corner case
                    if (top_left != null && top_right != null) {
                        concave_point = [bottom_left.positionX + bottom_left.sizeY / 2, top_right.positionY + top_right.sizeY / 2];


                        if (JSON.stringify(points_to_draw).indexOf(
                            JSON.stringify(concave_point)) == -1) {
                            points_to_draw.push(concave_point);
                        }
                    }

                    // Convex corner case
                    if (top_left == null) {
                        points_to_draw.push(droplet_draw_point);
                    }

                    if (JSON.stringify(points_to_draw).indexOf(
                        JSON.stringify([bottom_left.positionX + bottom_left.sizeX / 2,
                        bottom_left.positionY - bottom_left.sizeY / 2])) == -1 && top_left == null) {
                        points_to_draw.push([bottom_left.positionX + bottom_left.sizeX / 2, bottom_left.positionY - bottom_left.sizeY / 2]);
                    }

                    droplet_draw_point = [bottom_left.positionX + bottom_left.sizeX / 2, bottom_left.positionY + bottom_left.sizeY / 2];
                    current_droplet_point = [current_droplet_point[0], current_droplet_point[1] + check_size * 2];

                } else if (bottom_left == null && top_left != null) {

                    // Concave corner case
                    if (bottom_right != null && top_right != null) {
                        concave_point = [bottom_right.positionX - bottom_right.sizeY / 2, top_left.positionY + top_left.sizeY / 2];

                        if (JSON.stringify(points_to_draw).indexOf(
                            JSON.stringify(concave_point)) == -1) {
                            points_to_draw.push(concave_point);
                        }
                    }

                    // Convex corner case
                    if (top_right == null) {
                        points_to_draw.push(droplet_draw_point);
                    }

                    if (JSON.stringify(points_to_draw).indexOf(
                        JSON.stringify([top_left.positionX + top_left.sizeX / 2,
                        top_left.positionY + top_left.sizeY / 2])) == -1 && top_right == null) {
                        points_to_draw.push([top_left.positionX + top_left.sizeX / 2, top_left.positionY + top_left.sizeY / 2]);
                    }

                    droplet_draw_point = [top_left.positionX - top_left.sizeX / 2, top_left.positionY + top_left.sizeY / 2];
                    current_droplet_point = [current_droplet_point[0] - check_size * 2, current_droplet_point[1]];

                } else if (top_left == null && top_right != null) {

                    // Concave corner case
                    if (bottom_right != null && bottom_left != null) {
                        concave_point = [top_right.positionX - top_right.sizeY / 2, bottom_left.positionY - bottom_left.sizeY / 2];

                        if (JSON.stringify(points_to_draw).indexOf(
                            JSON.stringify(concave_point)) == -1) {
                            points_to_draw.push(concave_point);
                        }
                    }

                    // Convex corner case
                    if (bottom_right == null) {
                        points_to_draw.push(droplet_draw_point);
                    }

                    if (JSON.stringify(points_to_draw).indexOf(
                        JSON.stringify([top_right.positionX - top_right.sizeX / 2,
                        top_right.positionY + top_right.sizeY / 2])) == -1 && bottom_right == null) {
                        points_to_draw.push([top_right.positionX - top_right.sizeX / 2, top_right.positionY + top_right.sizeY / 2]);
                    }

                    droplet_draw_point = [top_right.positionX - top_right.sizeX / 2, top_right.positionY - top_right.sizeY / 2];
                    current_droplet_point = [current_droplet_point[0], current_droplet_point[1] - check_size * 2];
                }
            }


            p.fill(current_droplet.color);

            p.stroke(draw_config.group.borderColor);
            p.strokeWeight(draw_config.group.borderWidth);

            let points_vector = [];
            for (let j = 0; j < points_to_draw.length; j++) {
                points_vector.push(p.createVector(p.round(points_to_draw[j][0], 2), p.round(points_to_draw[j][1], 2)));
            }

            //console.log(points_vector);
            gui_broker.droplet_groups[current_droplet.group].vertices = points_to_draw;

            if (!selection_manager.layers.draw_droplet_animations.checkbox.checked) {
                draw_rounded(p, points_vector, 50);
            }


            //p.beginShape();
            /*for (let j = 0; j < points_to_draw.length; j++) {
                p.ellipse(points_to_draw[j][0], points_to_draw[j][1],5,5);
            }*/
            //p.endShape(p.CLOSE);

        }
    }

    /**
     * Will round the corners of a set of vertices.
     * From https://gorillasun.de/blog/An-algorithm-for-polygons-with-rounded-corners
     * @param {any} sketch
     * @param {any} points
     * @param {any} r
     */
    function draw_rounded(sketch, points, r) {
        sketch.beginShape();
        for (let i = 0; i < points.length; i++) {
            const a = points[i];
            const b = points[(i + 1) % points.length];
            const c = points[(i + 2) % points.length];
            const ba = a.copy().sub(b).normalize();
            const bc = c.copy().sub(b).normalize();

            // Points in the direction the corner is accelerating towards
            const normal = ba.copy().add(bc).normalize();

            // Shortest angle between the two edges
            const theta = ba.angleBetween(bc);

            // If theta is 0, theres no change in the angle, and we can continue
            if (theta == 0) { continue; }

            // Find the circle radius that would cause us to round off half
            // of the shortest edge. We leave the other half for neighbouring
            // corners to potentially cut.
            const maxR = sketch.min(a.dist(b), c.dist(b)) / 2 * sketch.abs(sketch.sin(theta / 2));
            const cornerR = sketch.min(r, maxR);
            // Find the distance away from the corner that has a distance of
            // 2*cornerR between the edges
            const distance = sketch.abs(cornerR / sketch.sin(theta / 2));

            // Approximate an arc using a cubic bezier
            const c1 = b.copy().add(ba.copy().mult(distance));
            const c2 = b.copy().add(bc.copy().mult(distance));
            const bezierDist = 0.5523; // https://stackoverflow.com/a/27863181
            const p1 = c1.copy().sub(ba.copy().mult(2 * cornerR * bezierDist));
            const p2 = c2.copy().sub(bc.copy().mult(2 * cornerR * bezierDist));
            sketch.vertex(c1.x, c1.y);
            sketch.bezierVertex(
                p1.x, p1.y,
                p2.x, p2.y,
                c2.x, c2.y
            )

            //console.log(p1, p2);
        }
        sketch.endShape(sketch.CLOSE);
    }


    /* Initialize board values */
    function init_board(sizeX, sizeY) {
        gui_broker.sketch_ref = p;

        p.resizeCanvas(sizeX + 1, sizeY);

        //layer_electrode_id = p.createGraphics(sizeX + 1, sizeY);


        for (let layer in selection_manager.layers) {
            if (selection_manager.layers[layer].hasOwnProperty("layer")) {
                selection_manager.layers[layer].layer = p.createGraphics(sizeX + 1, sizeY);
            }
        }
        for (let i = 0; i < gui_broker.electrodes.length; i++) {
            let electrode = gui_broker.electrodes[i];
            debug_electrode_text(selection_manager.layers.debug_electrode_text.layer, electrode);
        }

        draw_actuators(selection_manager.layers.draw_actuators.layer);
        draw_sensors(selection_manager.layers.draw_sensors.layer);

        layer_electrode = p.createGraphics(sizeX + 1, sizeY);

        draw_electrode();
    }
    gui_broker.init_board = init_board; // Attach the function to the GUI broker.

    

    /* Call to draw active electrodes */
    function draw_active_electrodes() {
        /* TODO: Maybe send information of which electrode is active from the simulator */
        for (let i = 0; i < gui_broker.electrodes.length; i++) {
            let electrode = gui_broker.electrodes[i];

            if (electrode.status == 0) { continue; }
            p.fill(draw_config.electrode.activeColor);
            
            // Check the electrode shape
            if (electrode.shape == 1) {
                p.beginShape();
                for (let i = 0; i < electrode.corners.length; i++) {
                    p.vertex(electrode.positionX + electrode.corners[i][0] + 0.5, electrode.positionY + electrode.corners[i][1] + 0.5);
                }
                p.endShape(p.CLOSE);
            } else {
                p.rect(electrode.positionX, electrode.positionY, electrode.sizeX, electrode.sizeY);
            }
        }
    }

    /* Call to draw electrode shapes */
    function draw_electrode() {
        for (let i = 0; i < gui_broker.electrodes.length; i++) {
            let electrode = gui_broker.electrodes[i];

            layer_electrode.stroke(draw_config.electrode.borderColor);
            layer_electrode.strokeWeight(draw_config.electrode.borderWidth);
            layer_electrode.fill(draw_config.electrode.backgroundColor);
            //if (electrode.status != 0) { layer_electrode_shape.fill("red"); }

            // Check the electrode shape
            if (electrode.shape == 1) {
                draw_polygon_electrode_shapes(electrode.positionX, electrode.positionY, electrode.corners);
            } else {
                layer_electrode.rect(electrode.positionX, electrode.positionY, electrode.sizeX, electrode.sizeY);
            }
        }
    }

    /* Call to draw polygonal shaped electrode shapes */
    function draw_polygon_electrode_shapes(posX, posY, corners) {
        layer_electrode.beginShape();
        for (let i = 0; i < corners.length; i++) {
            layer_electrode.vertex(posX + corners[i][0] + 0.5, posY + corners[i][1] + 0.5);
        }
        layer_electrode.endShape(layer_electrode.CLOSE);
    }

    /* Call to draw droplets */
    function draw_droplet() {
        for (let i = 0; i < gui_broker.droplets.length; i++) {
            let droplet = gui_broker.droplets[i];
            p.fill(droplet.color);
            p.stroke(draw_config.droplet.borderColor);
            p.strokeWeight(draw_config.droplet.borderWidth);
            p.ellipse(droplet.positionX, droplet.positionY, droplet.sizeX, droplet.sizeY);
        }
    }

    /* Call to draw actuators */
    function draw_actuators(layer) {
        let actuators = gui_broker.board.actuators;
        actuators.forEach((actuator) => {
            //console.log(actuator);
            let color = layer.color(draw_config.actuator.backgroundColor);
            color.setAlpha(draw_config.actuator.backgroundOpacity);
            layer.fill(color);
            layer.stroke(draw_config.actuator.borderColor);
            layer.strokeWeight(draw_config.actuator.borderWidth);
            layer.rect(actuator.positionX, actuator.positionY, actuator.sizeX, actuator.sizeY);
        })
    }

    /* Call to draw actuators */
    function draw_sensors(layer) {
        let sensors = gui_broker.board.sensors;
        sensors.forEach((sensor) => {
            //console.log(actuator);
            let color = layer.color(draw_config.sensor.backgroundColor);
            color.setAlpha(draw_config.sensor.backgroundOpacity);
            layer.fill(color);
            layer.stroke(draw_config.sensor.borderColor);
            layer.strokeWeight(draw_config.sensor.borderWidth);
            layer.rect(sensor.positionX, sensor.positionY, sensor.sizeX, sensor.sizeY);
        })
    }

    /* Call to draw bubbles */
    function draw_bubbles() {
        let bubbles = gui_broker.board.bubbles;

        if (typeof bubbles != 'undefined') {
            p.noFill();
            p.stroke(draw_config.bubble.borderColor);
            p.strokeWeight(draw_config.bubble.borderWidth);
            bubbles.forEach((bubble) => {
                p.ellipse(bubble.positionX, bubble.positionY, bubble.sizeX, bubble.sizeY);
            })
        }
    }

    /**
     * Call to draw ID's of all electrodes (used for debugging)
     * @param {any} layer
     * @param {any} electrode
     */
    function debug_electrode_text(layer, electrode) {
        let pos_x = 0;
        let pos_y = 0;

        if (electrode.shape == 1) {
            layer.fill(0, 255, 0);
            let corner_sum_x = 0;
            let corner_sum_y = 0;

            
            for (let i = 0; i < electrode.corners.length; i++) {
                corner_sum_x = parseInt(corner_sum_x) + (parseInt(electrode.positionX) + parseInt(electrode.corners[i][0]));
                corner_sum_y = parseInt(corner_sum_y) + (parseInt(electrode.positionY) + parseInt(electrode.corners[i][1]));
            }

            pos_x = (corner_sum_x) / (electrode.corners.length) - layer.textWidth(electrode.ID) / 2;
            pos_y = (corner_sum_y) / (electrode.corners.length) + layer.textAscent(electrode.ID) / 2;
            
        } else {
            layer.fill(255, 200, 0);
            pos_x = electrode.positionX + electrode.sizeX / 2 - layer.textWidth(electrode.ID)/2;
            pos_y = electrode.positionY + electrode.sizeY / 2 + layer.textAscent(electrode.ID)/2;
        }

        layer.textSize(6);
        layer.text(electrode.ID, pos_x, pos_y);
    }

};
/* BEGIN Global.js */

/**
 * This file contains functions declared in the global state,
 * by that it is inferred that they are bound to the window object.
 */

/**
 * The function setp5 initializes the p5js instance (the sketch),
 * and binds it to the element with id 'container'.
 */
window.setp5 = () => {
    new p5(sketch, window.document.getElementById('container'));
    return true;
};

/**
 * The functions start_update_timer and end_update_timer are used to
 * start and end timer used for time analysis.
 */
window.start_update_timer = () => {
    console.time("UpdateTimer");
}
window.end_update_timer = () => {
    console.timeEnd("UpdateTimer");
}

/**
 * The function update_board is one of the main driving functions of the
 * GUI-backend, it is used to update the information in the GUI directly from
 * the simulator.
 * @param {any} _container_string
 */
window.update_board = (_container_string) => {

    /* Convert JSON string to an object */
    let container_string = BINDING.conv_string(_container_string);
    var board = JSON.parse(container_string);

    /* Used to calculate time difference, which allows for realtime execution. */
    if (typeof gui_broker.board.currentTime != "undefined") {
        gui_broker.simulator_prev_time = gui_broker.board.currentTime;
    }

    /* Update the gui_broker information */
    gui_broker.board = board;
    gui_broker.droplets = board.droplets;
    gui_broker.electrodes = board.electrodes;
    gui_broker.prev_droplet_groups = gui_broker.droplet_groups;
    gui_broker.droplet_groups = gui_broker.get_droplet_groups();
    
    /* Allow dynamic selection */
    information_panel_manager.dynamic_update();

    /* End timer */
    console.timeEnd("UpdateTimer");

    /* Update the displayed time in the GUI */
    document.querySelector("#simulatorTime").innerHTML = gui_broker.board.currentTime;

    /* Trigger animation */
    animate_once();
}

/**
 * The function change_play_status is used pause or play the simulator, from
 * the GUI.
 * @param {any} status
 */
window.change_play_status = (status) => {
    gui_broker.play_status = !gui_broker.play_status;
};

/**
 * The function initialize_board is used to initialize the information needed
 * to create the GUI.
 * @param {any} information
 */
window.initialize_board = (information) => {

    /*
     * TODO: Check if we can fix initial realtime execution
     * by giving more information here!
     */

    /* Remove any previous sketch */
    if (gui_broker.sketch_ref != null) {
        gui_broker.sketch_ref.remove();
    }

    /* Convert JSON string to object */
    var JSONinformation = JSON.parse(information);
    gui_broker.init_board(JSONinformation.sizeX, JSONinformation.sizeY + 1);
    
    /* Display GUI elements */
    gui_controller.showGUI();
    gui_controller.changeBoardName(JSONinformation.platform_name);
    document.querySelector("#edit_button").style.visibility = "visible";

    //document.querySelector("#defaultCanvas0").style.width = "1000px";

    selection_manager.initialize_layers();
}

window.get_selected_element = () => {
    return JSON.stringify(information_panel_manager.selected_element);
}

/**
 * The function animate_once, will trigger one animation cycle in the GUI.
 */
window.animate_once = () => {
    gui_broker.animate = true;
    lerp_amount = 0;
}

/**
 * The function restart_board is called when we trigger a restart.
 */
window.restart_board = () => {
    gui_broker.animate = false;
    gui_broker.simulator_prev_time = 0;
    lerp_amount = 1;
}

/**
 * The function start_simulator_time is used to start the time,
 * we use for realtime execution.
 */
window.start_simulator_time = () => {
    gui_broker.simulator_time = Date.now();
}

/**
 * The function start_simulator_time is used to set the simulator time to a specific time
 */
window.set_simulator_time = (time) => {
    gui_broker.simulator_time = time;
}

/**
 * The function download_data is used to download simulator data,
 * into JSON format.
 */
window.download_data = () => {
    gui_controller.download_data();
    //let jsonData = JSON.stringify(gui_broker.data_to_download);

    ///* Download the data by forcing a click on an anchor element. */
    //var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(jsonData);
    //var dlAnchorElem = document.getElementById('downloadAnchorElem');
    //dlAnchorElem.setAttribute("href", dataStr);
    //dlAnchorElem.setAttribute("download", "data.json");
    //dlAnchorElem.click();

    //gui_broker.data_to_download = [];
}

/**
 * The function send_download_data is used by the simulator to send the data
 * to the GUI, which will then be formatted, so that it's ready for download.
 * @param {any} jsonData
 */
window.send_download_data = (jsonData) => {
    gui_controller.store_download_data(jsonData);
    //let obj = JSON.parse(jsonData);
    //obj.droplet_groups = gui_broker.get_droplet_groups();
    //gui_broker.data_to_download.push(obj);
}

/* Make the gui_broker a global object */
window.gui_broker = gui_broker;

/* END Global.js */