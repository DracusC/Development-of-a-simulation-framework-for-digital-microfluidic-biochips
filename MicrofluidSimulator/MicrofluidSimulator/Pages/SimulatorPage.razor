@page "/SimulatorPage"
@using MicrofluidSimulator.Components
@using MicrofluidSimulator.SimulatorCode.DataTypes
@using Microsoft.JSInterop
@using SimulatorCode
@using System.Text.Json.Serialization
@using MicrofluidSimulator.SimulatorCode.Simulator
@inject IJSInProcessRuntime JSInProcessRuntime
@inject IJSUnmarshalledRuntime JSUnmarshalledRuntime
@inject HttpClient Http
@using MicrofluidSimulator.SimulatorCode.View
@using System.Diagnostics
@using System.Text.Json
@using System.Text
@using System.Reflection

@using System.Net


@if(ModalOpen){
    <DownloadModal  @ref=downloadModal Title="Information editor" Text = "INSERT" OnClose="@CloseDownloadModal" OnSubmit="@SubmitDownloadModal"/>
}



<div id="simulatorGUI">
    <div id="simulatorContainer">

        <div id="sketchPanel">
            <div id="simulatorView">
                <div id="simulatorHeader">
                    <span>BOARD NAME</span>
                    <div><span>Simulation Time: </span><span id="simulatorTime"></span></div>
                </div>
                <div id='container'></div>
            </div>
        </div>
        
        <div id="controlPanel">
            <div id="button_div">
                <div>
                    <button id="nextStep" class="btn btn-primary" @onclick="gotoTime">Next Step</button>
                    <button class="btn btn-primary" @onclick="Play">@PlayButtonText</button>
                    <button class="btn btn-primary" @onclick="Restart">Restart</button>
                    <button id="" class="btn btn-primary" @onclick="DownloadDataButton">Download</button>
                </div>
                <div>
                    <span>TimeStep amount:</span>
                    <RadzenNumeric @bind-Value="timeStepAmount" TValue="float" Step="0.1" Placeholder="Enter or clear value" Change="onTimeStepChange"></RadzenNumeric>
                </div>
            </div>
            <div id="slider_div">
                <RadzenSlider id="time_slider" @bind-Value=@sliderValue TValue="int" Min="0" Max=@GlobalVariables.maxSliderValue Change="onSliderChange"></RadzenSlider>
                <button class="btn btn-primary" @onclick="GotoSliderTime">Goto Time: @sliderValue</button>
            </div>
        </div>
        

        <div id="informationPanelContainer">
            <div id="informationPanel">
                <div id="informationTitle">
                    <span>Information Panel</span>
                </div>

                <div id="information">
                    <button id="edit_button" class="btn btn-primary" style="visibility: hidden">Edit</button>
                    <div id="saveclose_button_div"><button id="save_button" class="btn btn-primary">Save</button><button id="cancel_button" class="btn btn-primary">Cancel</button></div>
                    <div id="informationElements"></div>
                </div>
            </div>

            <div id="selectionPanel">
                <span>Selection Panel</span>
                <form name="layer">

                </form>
            </div>
        </div>


        
    </div>
</div>

<a id="downloadAnchorElem" style="display:none"></a>


@code {


    // Download Modal Code START
    DownloadModal downloadModal;
    public bool ModalOpen { get; set; }
    private async Task CloseDownloadModal(bool accepted)
    {
        ModalOpen = false;
        StateHasChanged();
    }
    private async void OpenDownloadModal()
    {
        ModalOpen = true;
        StateHasChanged();
    }
    private async Task SubmitDownloadModal(bool accepted)
    {
        ModalOpen = false;
        Console.WriteLine("DOWNLOAD SUBMIT " + downloadModal.Time + " " + downloadModal.TimeStep);
        DownloadData(downloadModal.Time, downloadModal.TimeStep);
        StateHasChanged();
    }

    private void DownloadDataButton()
    {
        OpenDownloadModal();
    }

    /// <summary>
    /// Download simulation data
    /// </summary>
    [JSInvokable]
    public static void DownloadData(float endTime, float timeStep)
    {
        // Get the current time
        float timeBeforeDownload = simulator.container.currentTime;

        if(timeStep <= 0 && timeStep != -1)
        {
            timeStep = 0.1f;
        }

        // Restart simulation
        Restart();

        // Run the simulation and send the simulation data
        while(simulator.container.currentTime <= endTime)
        {
            string jsonStringForDownload = Utf8Json.JsonSerializer.ToJsonString(simulator.container);

            guibroker.send_download_data(jsonStringForDownload);

            nextStepTime(timeStep);
        }

        // Flag data ready for download
        guibroker.download_data();

        // Go back to previous time
        Restart();
        gotoSimulatorTimeStep(timeBeforeDownload);

    }

    // Download Modal Code END

    int sliderValue = 0;
    static float timeStepAmount = -1;
    static float actualTimeStepAmount = 0;

    public void onTimeStepChange()
    {
        if(timeStepAmount <= 0)
        {
            timeStepAmount = -1;
        }
    }

    public void onSliderChange()
    {
        //Restart();
        //nextStepTime((float)sliderValue);
    }


    // Get the GUIBroker object reference
    static GUIBroker guibroker = new GUIBroker();

    bool test = true;
    static Stopwatch stopwatch = new Stopwatch();

    private void NextStep() {
        simulator.simulatorStep(-1);
        guibroker.update_board(simulator.container);
    }

    public static string PlayButtonText { get; set; } = "Play";
    public void Play() {
        PlayButtonText = PlayButtonText.Equals("Play") ? "Pause" : "Play";
        InvokeAsync(() => StateHasChanged());
        guibroker.change_play_status();
        guibroker.start_simulator_time();
    }

    [JSInvokable]
    public static void JSSimulatorNextStep() {
        guibroker.start_update_timer();
        simulator.simulatorStep(-1);
        dumbVM.doApiCall();
        if(PlayButtonText == "Play") { guibroker.animate_once(); }
        guibroker.update_board(simulator.container);
    }
    [JSInvokable]
    public static void nextStepTime(float deltaTime)
    {
        float tempTimeStep = timeStepAmount;
        timeStepAmount = deltaTime;
        gotoTime();
        timeStepAmount = tempTimeStep;

        //simulator.simulatorStep(deltaTime);
        //guibroker.update_board(simulator.container);
    }
    [JSInvokable]
    public static void gotoSimulatorTimeStep(float deltaTime)
    {
        simulator.restartSimulator();
        simulator.simulatorStep(deltaTime);
        guibroker.update_board(simulator.container);
    }

    public static void gotoTime()
    {
        float startSimulatorTime = simulator.container.currentTime;

        while(simulator.container.currentTime < timeStepAmount + startSimulatorTime)
        {
            Console.WriteLine(timeStepAmount + startSimulatorTime + " : " + simulator.container.currentTime);
            Console.WriteLine(simulator.actionQueue.Count);

            float simulatorTimeStep = 0;
            if(simulator.actionQueue.Count != 0) {
                simulatorTimeStep = simulator.actionQueue.Peek().time;
            }

            if(simulatorTimeStep > timeStepAmount)
            {
                Console.WriteLine(timeStepAmount);
                simulator.simulatorStep(timeStepAmount);
                dumbVM.doApiCall();
            } else
            {
                simulator.simulatorStep(-1f);
                dumbVM.doApiCall();
            }
        }

        if(timeStepAmount <= 0)
        {
            simulator.simulatorStep(-1f);
            dumbVM.doApiCall();
        }

        guibroker.update_board(simulator.container);
    }


    public void GotoSliderTime()
    {
        Restart();
        //nextStepTime((float)sliderValue);
        float startSimulatorTime = simulator.container.currentTime;
        float simulatorTimeStep = 0;
        while(simulator.container.currentTime < (float)sliderValue + startSimulatorTime)
        {
            Console.WriteLine((float)sliderValue + startSimulatorTime + " : " + simulator.container.currentTime);


            if(simulator.actionQueue.Count != 0) {
                simulatorTimeStep = simulator.actionQueue.Peek().time;
            }

            if(simulatorTimeStep > (float)sliderValue)
            {
                Console.WriteLine((float)sliderValue);
                simulator.simulatorStep((float)sliderValue);
                dumbVM.doApiCall();
            } else
            {
                simulator.simulatorStep(-1f);
                dumbVM.doApiCall();
            }
        }

        guibroker.update_board(simulator.container);
        simulator.simulatorStep(-2f);
        guibroker.update_board(simulator.container);
    }

    /// <summary>
    /// Restarts the simulation
    /// </summary>
    public static void Restart()
    {
        simulator.restartSimulator();
        guibroker.update_board(simulator.container);
        guibroker.restart_board();
    }

    

    
    /// <summary>
    /// The function updateSimulatorContainer is used to update the simulator elements,
    /// based on edited values from the GUI.
    /// </summary>
    /// <param name="Type"></param>
    /// <param name="JSONString"></param>
    [JSInvokable]
    public static void updateSimulatorContainer(string Type, string JSONString)
    {
        // [(key -> value)] [ID1 -> 1, "Status" -> 1]
        Console.WriteLine(Type);
        Console.WriteLine(JSONString);

        int ID;
        int index;

        switch (Type)
        {
            case ("Electrode"):
                Electrode JSONElectrode = Newtonsoft.Json.JsonConvert.DeserializeObject<Electrode>(JSONString);

                ID = JSONElectrode.ID;
                index = MicrofluidSimulator.SimulatorCode.Models.HelpfullRetreiveFunctions.getIndexOfElectrodeByID(ID, simulator.container);

                Electrode electrode = simulator.container.electrodes[index];

                // Change values
                electrode.status = JSONElectrode.status;
                break;

            case ("Droplet"):
                MicrofluidSimulator.SimulatorCode.Droplets JSONDroplet = Newtonsoft.Json.JsonConvert.DeserializeObject<MicrofluidSimulator.SimulatorCode.Droplets>(JSONString);
                ID = JSONDroplet.ID;
                index = MicrofluidSimulator.SimulatorCode.Models.HelpfullRetreiveFunctions.getIndexOfDropletByID(ID, simulator.container);

                Console.WriteLine("ID: " + ID + ", index: " + index);

                MicrofluidSimulator.SimulatorCode.Droplets droplet = (MicrofluidSimulator.SimulatorCode.Droplets)simulator.container.droplets[index];

                // Change values
                droplet.color = JSONDroplet.color;
                droplet.temperature = JSONDroplet.temperature;
                droplet.volume = JSONDroplet.volume;
                break;

            case ("Group"):
                Console.WriteLine(JSONString);
                GroupDroplets JSONGroupDroplets = Newtonsoft.Json.JsonConvert.DeserializeObject<GroupDroplets>(JSONString);

                List<Droplets> dropletList = new List<Droplets>();

                foreach (int dropletID in JSONGroupDroplets.droplets)
                {
                    index = MicrofluidSimulator.SimulatorCode.Models.HelpfullRetreiveFunctions.getIndexOfDropletByID(dropletID, simulator.container);
                    droplet = (MicrofluidSimulator.SimulatorCode.Droplets)simulator.container.droplets[index];

                    // Change values for each droplet in a group
                    droplet.color = JSONGroupDroplets.color;
                    droplet.temperature = JSONGroupDroplets.temperature;
                }

                float prevVolume = MicrofluidSimulator.SimulatorCode.Models.DropletUtillityFunctions.getGroupVolume(simulator.container, JSONGroupDroplets.groupID);

                float deltaVolume = JSONGroupDroplets.volume - prevVolume;
                Console.WriteLine("PrevVolume " + prevVolume + " , diff " + deltaVolume + " GID " + JSONGroupDroplets.groupID);

                MicrofluidSimulator.SimulatorCode.Models.DropletUtillityFunctions.updateGroupVolume(simulator.container, JSONGroupDroplets.groupID, deltaVolume);

                Console.WriteLine("Updated Volume: " + MicrofluidSimulator.SimulatorCode.Models.DropletUtillityFunctions.getGroupVolume(simulator.container, JSONGroupDroplets.groupID));

                break;
        }

        // -2 signals an update on models not time
        simulator.simulatorStep(-2);

        guibroker.update_board(simulator.container);
    }

    private Container? container;
    private static Simulator? simulator;
    private static MicrofluidSimulator.SimpleVM.SimpleVM? dumbVM;
    private MicrofluidSimulator.SimulatorCode.DataTypes.ElectrodesWithNeighbours[]? electrodesWithNeighbours;

    /// <summary>
    /// OnAfterRender is triggered when a render change is happening, we initialize on first render.
    /// </summary>
    /// <param name="firstRender"></param>
    protected override async void OnAfterRender(bool firstRender) {
        if (firstRender) {

            
            container = await Http.GetFromJsonAsync<Container>("sample-data/platform640v2.json");
            electrodesWithNeighbours = await Http.GetFromJsonAsync<MicrofluidSimulator.SimulatorCode.DataTypes.ElectrodesWithNeighbours[]>("sample-data/platform640v2neighbours.json");
            string actionQueueInstructions = await Http.GetStringAsync("sample-data/simple_paths_commands.txt");

            simulator = new Simulator(null, container, electrodesWithNeighbours, actionQueueInstructions);
            dumbVM = new MicrofluidSimulator.SimpleVM.SimpleVM(simulator);

            guibroker.set_jsprocess(JSInProcessRuntime);
            guibroker.set_unmarshall(JSUnmarshalledRuntime);
            guibroker.setP5();
            guibroker.start_update_timer();
            guibroker.update_board(simulator.container);
            guibroker.initialize_board(container.information);
        }
    }
}